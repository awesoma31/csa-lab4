# Чураков Александр Алексеевич, P3231

Архитектуры компьютерных систем, лабораторная работа №4, 2025

вариант -> `alg | cisc | harv | hw | tick | binary | trap | port | pstr | prob2 | vector`

описание задания [здесь](https://gitlab.se.ifmo.ru/computer-systems/csa-rolling/-/blob/master/lab4-task.md)

---

## Содержание

1. [Язык программирования](#язык-программирования)
2. [Организация памяти](#организация-памяти)
3. [Система команд](#система-команд)
4. [Транслятор](#транслятор)
5. [Модель процессора](#модель-процессора)
6. [Тестирование](#тестирование)
7. [Пример использования](#пример-использования)
8. [Пример тестирования исходного кода](#пример-тестирования-исходного-кода)
9. [Общая статистика](#общая-статистика)

## Язык программирования

**Синтаксис** 

!TODO

Ключевые слова:

`let if else while print read readInt list inter intOn intOff addL addStr`.

(идентификаторы, совпадающие с ключевым словом, зарезервированы).

```
<letter>        ::= "A"…"Z" | "a"…"z" | "_"
<digit>         ::= "0"…"9"

<identifier>    ::= <letter> { <letter> | <digit> }
<int-literal>   ::= <digit> { <digit> }
<string-literal>::= '"' { ‹любой символ, кроме " и \ или экранированной последовательности› } '"'

<program>           ::= { <decl-or-stmt> }

<decl-or-stmt>      ::= <var-decl>
                      | <stmt>
                      | <interrupt-decl>

<var-decl>          ::= "let" <identifier> [ "=" <expression> ] ";"

<interrupt-decl>    ::= "inter" <int-literal> <block>
<iocontrol-stmt>    ::= "intOn"  ";" | "intOff" ";"

<stmt>              ::= <iocontrol-stmt>
                      | <print-stmt>
                      | <assignment>
                      | <if-stmt>
                      | <while-stmt>
                      | <block>
                      | <expression> ";"          *выражение-как-оператор*

<print-stmt>        ::= "print" "(" <expression> ")" ";"

<assignment>        ::= <lvalue> "=" <expression> ";"
<lvalue>            ::= <identifier> [ "[" <expression> "]" ]

<if-stmt>           ::= "if" <expression> <block> [ "else" <block> ]
<while-stmt>        ::= "while" <expression> <block>

<block>             ::= "{" { <decl-or-stmt> } "}"


<expression>        ::= <logic-or>
<equality>          ::= <relational>{ ("==" | "!=") <relational> }
<relational>        ::= <additive>  { ("<" | "<=" | ">" | ">=") <additive> }
<additive>          ::= <multiplicative> { ("+" | "-") <multiplicative> }
<multiplicative>    ::= <unary> { ("*" | "/") <unary> }
<unary>             ::= [ "+" | "-" ] <primary>
<primary>           ::= <literal>
                      | <lvalue>
                      | <func-call>
                      | "(" <expression> ")"

<func-call>         ::= ("addL" | "addStr") "(" [ <arg-list> ] ")";
<arg-list>          ::= <expression> { "," <expression> }

<literal>           ::= <int-literal> | <string-literal>



```

**Семантика**

- Семантические пометки:

  - Переменные имеют глобальную область видимости, должны начинаться с латинской буквы, чувствительны к регистру, при объявлении должно быть явно указано значение.

  - Типизация динамическая с неявным приведением.

  - Констант нет.

  - Массивы — объект “list”, доступ к элементу через индекс `arr[i]`;

  - Строки — Pascal-style в памяти, но на уровне языка отображаются как обычные строковые литералы;

  - обработчики `inter N { ... }` компилируются в отдельную секцию командной памяти и вызываются моделью процессора при поступлении прерывания N;

  - Директивы `intOff;` / `intOn;` генерируют особые CISC-инструкции, запрещающие IRQ.

  - Каждое ключевое слово заканчивает инструкцию точкой с запятой, кроме заголовков управляющих конструкций (if, while, inter), за которыми следует блок `{ … }`.
  - Коментарии начинаются с `//` и идут до конца стркои.

**Стратегия вычислений**

Код выполняется последовательно.

Переменные должны быть объявлены до использования.

При использовании переменной транслятор подставит адрес значения. #TODO

При вычислении сложных математических выражений промежуточный результат будет сохраняться на стеке.

Логика обработки прерывания задается в конце файла, в блоке `inter n {}`, где `n` - номер прерывания (1 или 2).

**Память**

- Распределяется статически на этапе трансляции.

- Строковые литералы помещаются в память в начале работы программы в формате Pascal-string.

- Числовые переменные хранятся в little endian формате.
  Long переменная хранятся в порядке - low, high.

- Под массив пользователь должен заранее выделить область в памяти данных.

- Память выравнивается, если строка или массив занимает некратное 4 значение байт.

## Организация памяти

- Гарвардская архитектура
- Размер машинного слова:
  - Память инструкций - 32 бита.
  - Память данных 8 бит.
- Адресация – прямая абсолютная.
- В памяти данных хранятся строки и переменные.
- В памяти команд хранятся инструкции и их операнды.
- Память команд - только для чтения.
- Программист не может управлять, какие регистры будут использоваться и когда будет использоваться стек.
- В начале памяти команд n ячеек занимают вектора обработки прерывания. Их количество оперделяется в конфигурации процессора `max_interruptions`.
- Динамические данные хранятся в памяти данных после адреса начала стека.

Регистры: 

!TODO

Имеется набор из 16 адресуемых регистров общего назначения, и несколько вспомогательных, для внутреннего исполнения инструкции.

PC указывает на адрес исполняемой инструкции и инкрементируется на каждом такте.

IR хранит управляющее слово инструкции (первое).

Организация стека:

- Стек это область памяти.
- Стек располагается в памяти данных, через фиксированное количество ячеек после последней инструкции, растет вниз.
- Программист не может управлять стеком напрямую.

```
      Instruction memory
+------------------------------+
| 00 : int vector 0            |
|   ...                        |
| n  : int vector n            |
| n+1: instruction             |
|   ...                        |
|  m : instruction             |
|   ...                        |
+------------------------------+

          Data memory
+------------------------------+
| 00  : var   1                |
|    ...                       |
|  n  : array 2                |
|  m  : str(len)               |
|     : str(byte1)             |
|    ...                       |
|    ...                       |
|    ...                       |
|  st :   SP                   |
|    ... heap                  |
+------------------------------+
```

- Прерывания

  - При поступления запроса на прерывание, если процессор находится на стадии исполнения инструкции, значение на соответствующе порту входа обновиться, но переход в прерывание наступит только после окончания исполнения инструкции.
  - Вложенные прерывания запрещены.
  - Если прерывание наступает во врея исполнения другого, или когда в очереди уже есть прерывание, его исполнение игнорируется.
  - Состояние процессора сохраняется во второй набор регистров и восстанавливается по окончанию.

## Система команд

- Машинное слово - 32 бита
- Доступ к памяти по адресу из регистра общего назанчения.
- Ус-ва ввода/вывода - port-mapped, доступно 3 ус-ва.
  - IO-Char - строковый ввод/вывод, автоматически при выводе строк и переменных, указывающих на строку. `print("foo");`, `print(name);`, `let a = read();`.
  - IO-Digit - ввод/вывод 32 битных знаковых значений, автоматически в зависимости от типа аргумента. `print(1);`, `print(number);`, `let b = readInt();`.
  - IO-Long - вывод 64 битных знаковых значений, автоматически в зависимости от типа переменной.`print(long)`.
- Поток управления:
  - Цикл `while a <= 10 {...}`
  - Условные переходы
  ```
  if points < 60 {
      print("PSJ")
  } else {
      kurs = kurs + 1
  }
  ```
  - Обработка прерываний описывается в блоке
    `inter 0 { ... }`

**Инструкции**

Инструкция представляет из себя заглавное слово, в котором кодируется opcode, режим и регистры (если это ввод/вывод, то порт).

Далее, в зависимости от режима в целых машинных словах идут операнды.

```
	31          26 25       21 20    17 16    13 12     9   8-0
	┌────────────┬──────────┬────────┬────────┬────────┬──────┐
	│  OPCODE 6b │ MODE 5b  │  RD 4b │ RS1 4b │ RS2 4b │ ...  │
	└────────────┴──────────┴────────┴────────┴────────┴──────┘

```

!TODO isa ref

детальное описание ISA [здесь]()

## Транслятор

[Реализация](pkg/translator/)

- Использование:

  - `./tranlator -in=path [-o=dir][-debug][-h]`

    - `-debug` - отображает все логи в stdout.

    - `-h` - помощь в использовании.

    - `-o` - путь до директории, в которую сохранить бинарные файлы и логи.

- Этапы трансляции:
  - Токенизация.
  - Парсинг, с построением AST-древа.
  - Генерация машинного кода в бинарные файлы `instr.bin` и `data.bin`.

- Особенности:
  - Длина объявляемых строк должна помещаться в 1 байт.

## Модель процессора

!TODO
[Схемы](docs/schemas/).

ControlUnit:

![ControlUnit](docs/schemas/CU-csa-lab4.png)

DataPath:

![DataPath](docs/schemas/DP-csa-lab4.png)




[Реализация](pkg/machine/) в pkg/machine.

- Использование:

  - `./machine [-conf=path]`

    - `-conf` - путь до yaml файла конфигурации и расписания ввода.

```
instruction_bin: "cat/instr.bin"
data_bin: "cat/data.bin"

debug: false
log_file: "cpu.log"

tick_limit: 1000
schedule:
  - tick: 50
    input:
      interrupt: 1
      value: "G"
  - tick: 300
    input:
      interrupt: 0
      value: 0

max_interruptions: 2

```

Пример [`instr.bin`](golden/hello/instr.bin):


Выходные данные: !TODO 
```
TICK    0 @ 0x77E00000 -  IntOff NoOperands; PC++ | PC=3/0x3
TICK    1 - interruptions on | false
TICK    2 @ 0x04220000 -  MOV MvImmReg; PC++ | PC=4/0x4
TICK    3 - RM1<-#5; PC++ | SP=256/0x100
TICK    4 @ 0x0B802000 -  PUSH SingleReg; PC++ | PC=6/0x6
TICK    5 - SP=SP-4 | SP=252/0xFC
TICK    6 - memD[0xFC]<-RM1 | memD[0xFC]=0x5
TICK    7 - memD[0xFD]<-RM1 | memD[0xFD]=0x0
TICK    8 - memD[0xFE]<-RM1 | memD[0xFE]=0x0
TICK    9 - memD[0xFF]<-RM1 | memD[0xFF]=0x0
TICK   10 @ 0x04240000 -  MOV MvImmReg; PC++ | PC=7/0x7
TICK   11 - RM2<-#3; PC++ | SP=252/0xFC
...
port Char | hello world
port Digit| 0 1 2 3
```

**Описание реализации:**

- `hardwired` - логика дешифрации инструкции скрыта, 
[релизована](pkg/machine/cpu.go)
 на golang в методе `fetch`.
- Метод `machine.Run()` моделирует работу процессора потактово.
- Шаг моделирования соответствует выполнению одной стадии инструкции с выводом в лог.  
- На каждом шаге вызывается фукнция шага `cpu.step()` которая присваивается при дешифрации инструкции, см. [micro.go](pkg/machine/micro.go) и `fetch`.
- Переполнение стека должно контроллироваться пользователем
- Флаги: стандартные N, Z, V, C, выставляются после сравнения или математической операции.

**Ввод/вывод**

реализация [io/controller.go](pkg/machine/io/controller.go).


## Тестирование 

Запустить все тесты: `go test ./... -v` или `make test`.

Обновить конигурацию golden-тестов можно при помощи флага `-u`:
```
cd golden
go test ./golden -u
```


Запуск golden-тестов реализован в файле [golden_test.go](golden/golden_test.go),

Логика golden-тестов - [internal/testingutil/helper.go](internal/testingutil/helper.go)

Ресурсы для golden-тестов расположены в директории [golden](golden/).

**Тестовое покрытие** !TODO

- `hello` - вывести строку "hello world".
- `hello_username` - печатает на выход приветствие пользователя.
- `cat` – повторяет поток ввода на вывод.
- `ast` - проверка составления AST - [parser_test.go](pkg/translator/parser/parser_test.go).
- `math` - проверяет корректность вычислений сложных математических выражений.
- `sort` - проверяет сортировку списка чисел. 
- `alg` – prob2 - считает разницу между суммой квадратов первых 100 натуральных чисел и квадратом их суммы.

CI для GitHub Actions - [cli.yml](.github/workflows/cli.yml)

Стадии CI:
  - gofmt all
  - golint
  - test
# csa-lab4

# CSA lab4

вариант -> alg | cisc | harv | hw | tick | binary | trap | port | pstr | prob2 | vector

```
<program>         ::= <stmt_list>

<stmt_list>       ::= <stmt> | <stmt> <stmt_list>

<letter>          ::= [a-z] | [A-Z]

<digit>           ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<number>          ::= [-2^31; 2^31 - 1]

<string>          ::= "\"" { <character> } "\""

<stmt>            ::= <expr_stmt>
                    | <var_decl>
                    | <if_stmt>
                    | <while_stmt>
                    | <block>
                    | <func_decl>
                    | <return_stmt>

<expr_stmt>       ::= <expression> ";"

<var_decl>        ::= "var" <identifier> [ "=" <expression> ] ";"

<if_stmt>         ::= "if" "(" <expression> ")" <stmt> [ "else" <stmt> ]

<while_stmt>      ::= "while" "(" <expression> ")" <stmt>

<block>           ::= "{" <stmt_list> "}"

<func_decl>       ::= "fn" <identifier> "(" [ <param_list> ] ")" <block>

<param_list>      ::= <identifier> | <identifier> "," <param_list>

<return_stmt>     ::= "return" [ <expression> ] ";"

<expression>      ::= <assignment>

<assignment>      ::= <identifier> "=" <assignment>
                    | <logic_or>

<logic_or>        ::= <logic_and> | <logic_or> "||" <logic_and>

<logic_and>       ::= <equality> | <logic_and> "&&" <equality>

<equality>        ::= <comparison>
                    | <equality> ( "==" | "!=" ) <comparison>

<comparison>      ::= <term>
                    | <comparison> ( "<" | ">" | "<=" | ">=" ) <term>

<term>            ::= <factor>
                    | <term> ( "+" | "-" ) <factor>

<factor>          ::= <unary>
                    | <factor> ( "*" | "/" | "%" ) <unary>

<unary>           ::= ( "!" | "-" ) <unary>
                    | <primary>

<primary>         ::= <number>
                    | <string>
                    | "true"
                    | "false"
                    | "null"
                    | <identifier>
                    | "(" <expression> ")"

<identifier>      ::= <letter> { <letter_or_digit> }


<letter_or_digit> ::= <letter> | <digit>


<character>       ::= любой символ, кроме "\"" и перевода строки
```

- alg: java, lua, go like syntax

  add В тестах необходимо осуществить проверку AST (абстрактного синтаксического дерева, полученного в процессе трансляции).

- cisc -- система команд должна содержать сложные инструкции:

  Арифметические операции, работающие с регистрами и памятью за одну операцию.
  Работа со специальными регистрами.
  Инструкции с переменным числом аргументов и, соответственно, с переменным количеством машинных слов для кодирования (к примеру, расчёт многочлена: с0+c1x1+c2x2+...+cnxnс_0 + c_1x_1 + c_2x_2 + ... + c_nx_nс0​+c1​x1​+c2​x2​+...+cn​xn​). Выборка инструкции должна явно производить смену машинного слова.

  считается ли разбиение ассемблерной команды (add [0x8], ACC) внутри процессора на выполнение нескольких команд (get from mem [0x8] подставить )

- harv -- Гарвардская архитектура:

  В тестах необходимо привести/проверить как память команд, так и память данных.

- hw -- hardwired. Реализуется как часть модели.

- tick -- процессор необходимо моделировать с точностью до такта, процесс моделирования может быть приостановлен на любом такте.

- binary -- бинарное представление.

  Требуются настоящие бинарные файлы, а не текстовые файлы с 0 и 1.

  Требуется отладочный вывод в текстовый файл вида:

  <address> - <HEXCODE> - <mnemonic>
    20 - 03340301 - add #01 <- 34 + #03

- trap

  Ввод-вывод осуществляется токенами через систему прерываний. Логика работы:

  При старте модели у вас есть расписание ввода ([(1, 'h'), (10, 'e'), (20, 'l'), (25, 'l'), (100, 'o')], где число -- момент поступления данных, символ -- токен).
  Процессор имеет систему прерываний:

  прерывания считаем внутренними;
  обработка прерывания должна приводить к вызову реализованного пользователем программного кода;
  обработчик прерывания реализуется программистом на вашем языке.

  В процессе моделирования идёт отсчёт времени в тактах, по наступлению события ввода -- происходит обработка прерывания.
  Из журнала работы процессора должно быть ясно, работаете вы в прерывании или нет.
  Вывод данных реализуется посимвольно, как в варианте stream, по выполнении команд в буфер вывода добавляется ещё один символ.
  По окончании моделирования показать все выведенные данные.
  Ситуация наступления прерывания во время обработки прерывания должна быть проработана (способ -- на ваше усмотрение).
  Логика работы с буферами реализуется в рамках модели на Python.
  Не стоит путать "вызов прерывания" и "получение данных".
  Нет магическим очередям.

- port -- port-mapped (специальные инструкции для ввода-вывода)

  адресация портов ввода-вывода должна присутствовать.

- pstr -- Length-prefixed (Pascal string)
  Общие требования:

  Статические строки должны храниться в памяти (секции) данных.
  Один символ может храниться в одном машинном слове (несмотря на явную неэффективность).
  Работа со строками реализуется процедурами или функциями на разработанном вами языке.

- prob2

- vector -- векторная организация работы процессора.

Необходимо реализовать векторные регистры и инструкции для работы с ними.
Минимальный набор операций: сложение, вычитание, умножение, деление, сравнение.
Необходимо продемонстрировать эффективность векторизации.
В отчете необходимо привести сравнение производительности векторной и скалярной реализаций алгоритма.
Рабочая цепочка: исходная программа на разработанном языке → транслятор генерирует бинарный файл с машинным кодом → симулятор процессора (на Go) исполняет код, генерируя подробный журнал (лог) работы с тактовым моделированием и обработкой прерываний.

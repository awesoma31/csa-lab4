# csa-lab4

# CSA lab4

вариант -> alg | cisc | harv | hw | tick | binary | trap | port | pstr | prob2 | vector

- alg: java, lua, go like syntax

  add В тестах необходимо осуществить проверку AST (абстрактного синтаксического дерева, полученного в процессе трансляции).

- cisc -- система команд должна содержать сложные инструкции:
  Кодировка ключевых опкодов (OPC)

  Арифметические операции, работающие с регистрами и памятью за одну операцию.
  Работа со специальными регистрами.
  Инструкции с переменным числом аргументов и, соответственно, с переменным количеством машинных слов для кодирования (к примеру, расчёт многочлена: с0+c1x1+c2x2+...+cnxnс_0 + c_1x_1 + c_2x_2 + ... + c_nx_nс0​+c1​x1​+c2​x2​+...+cn​xn​). Выборка инструкции должна явно производить смену машинного слова.

  instr format - [<prefix?> <opcode> <addr-mode> <imm/disp>] - 1-4 bytes

| OPC (hex) | Операция     | `SZ` применимо? | `NARGS` типично | Краткое описание / пример                             |
| --------- | ------------ | --------------- | --------------- | ----------------------------------------------------- |
| **0x00**  | **ADDN**     | ✅              | 2 – 15          | `ADDN R0, op1, op2, …` — суммирует _N_ операндов      |
| **0x01**  | **MULN**     | ✅              | 2 – 15          | `MULN R0, …` — произведение _N_ операндов             |
| **0x02**  | **POLY**     | ✅              | 3 – 15          | `POLY R0, X, c0, c1, …, cn` — свёртка Горнера         |
| **0x03**  | **SUB**      | ✅              | 2               | `SUB  R0, src` — вычитание (_dst ← dst − src_)        |
| **0x04**  | **DIV**      | ✅              | 2               | `DIV  R0, src` — целочисленное деление (многотактное) |
| **0x05**  | **MOD**      | ✅              | 2               | `MOD  R0, src` — остаток от деления                   |
| **0x08**  | **LD**       | ✅              | 1               | `LD   R0, [addr]` — загрузка из памяти                |
| **0x09**  | **ST**       | ✅              | 1               | `ST   R0, [addr]` — запись в память                   |
| **0x0A**  | **IN**       | —               | 1               | `IN   R0, port#` — ввод (port-mapped I/O)             |
| **0x0B**  | **OUT**      | —               | 1               | `OUT  R0, port#` — вывод                              |
| **0x0C**  | **VADD**     | vec-4           | 2               | `VADD V0, Vs, Vt, #len` — векторное сложение          |
| **0x0D**  | **VCMP**     | vec-4           | 2               | векторное сравнение, формирует маску-флаги            |
| **0x0E**  | **VSUB**     | vec-4           | 2               | векторное вычитание                                   |
| **0x0F**  | **VMUL**     | vec-4           | 2               | векторное умножение                                   |
| **0x10**  | **VDIV**     | vec-4           | 2               | векторное деление (по элементам)                      |
| **0x1F**  | **TRAP_RET** | —               | 0               | возврат из обработчика прерывания                     |
| **0x20**  | **JMP**      | —               | 1               | безусловный переход                                   |
| **0x21**  | **JCC**      | —               | 1               | условный переход по флагам                            |

var b = 1+1+1+1+1

| Addr | Word (hex)    | Расшифровка                          |
| ---- | ------------- | ------------------------------------ |
| 0000 | `00 05 01 00` | `OPC=ADDN, NARGS=5, DST=R1, SZ=word` |
| 0001 | `40 00 00 01` | ImmSmall 1                           |
| 0002 | `40 00 00 01` | ImmSmall 1                           |
| 0003 | `40 00 00 01` | …                                    |
| 0004 | `40 00 00 01` | …                                    |
| 0005 | `40 00 00 01` | …                                    |

- harv -- Гарвардская архитектура:

  В тестах необходимо привести/проверить как память команд, так и память данных.

- hw -- hardwired. Реализуется как часть модели.

- tick -- процессор необходимо моделировать с точностью до такта, процесс моделирования может быть приостановлен на любом такте.

- binary -- бинарное представление.

  Требуются настоящие бинарные файлы, а не текстовые файлы с 0 и 1.

  Требуется отладочный вывод в текстовый файл вида:

  <address> - <HEXCODE> - <mnemonic>
    20 - 03340301 - add #01 <- 34 + #03

- trap

  Ввод-вывод осуществляется токенами через систему прерываний. Логика работы:

  При старте модели у вас есть расписание ввода ([(1, 'h'), (10, 'e'), (20, 'l'), (25, 'l'), (100, 'o')], где число -- момент поступления данных, символ -- токен).
  Процессор имеет систему прерываний:

  прерывания считаем внутренними;
  обработка прерывания должна приводить к вызову реализованного пользователем программного кода;
  обработчик прерывания реализуется программистом на вашем языке.

  В процессе моделирования идёт отсчёт времени в тактах, по наступлению события ввода -- происходит обработка прерывания.
  Из журнала работы процессора должно быть ясно, работаете вы в прерывании или нет.
  Вывод данных реализуется посимвольно, как в варианте stream, по выполнении команд в буфер вывода добавляется ещё один символ.
  По окончании моделирования показать все выведенные данные.
  Ситуация наступления прерывания во время обработки прерывания должна быть проработана (способ -- на ваше усмотрение).
  Логика работы с буферами реализуется в рамках модели на Python.
  Не стоит путать "вызов прерывания" и "получение данных".
  Нет магическим очередям.

- port -- port-mapped (специальные инструкции для ввода-вывода)

  адресация портов ввода-вывода должна присутствовать.

- pstr -- Length-prefixed (Pascal string)
  Общие требования:

  Статические строки должны храниться в памяти (секции) данных.
  Один символ может храниться в одном машинном слове (несмотря на явную неэффективность).
  Работа со строками реализуется процедурами или функциями на разработанном вами языке.

- prob2

- vector -- векторная организация работы процессора.

Необходимо реализовать векторные регистры и инструкции для работы с ними.
Минимальный набор операций: сложение, вычитание, умножение, деление, сравнение.
Необходимо продемонстрировать эффективность векторизации.
В отчете необходимо привести сравнение производительности векторной и скалярной реализаций алгоритма.
Рабочая цепочка: исходная программа на разработанном языке → транслятор генерирует бинарный файл с машинным кодом → симулятор процессора (на Go) исполняет код, генерируя подробный журнал (лог) работы с тактовым моделированием и обработкой прерываний.
